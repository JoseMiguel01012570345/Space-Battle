
<center><h1><font size="20px">Space Battle</font></h1></center>

<font size="3px">

**`Space Battle`** is an interactive simulation where the confrontation between two teams is modeled in a determined space to achieve an objective, to defeat the other team.

In the simulation, two teams participate, each composed of a commander and a set of subordinates at their disposal. Additionally, each member of each team is equipped with the ability to destroy members of the opposing team. Each team's objective is to capture the flag of the opposing team. The simulation ends when one of the two teams captures the flag of the other or one of the two commanders is destroyed.

## Scenario

The simulation takes place in the cosmos, in a finite space filled with obstacles randomly distributed throughout the defined space. The teams are made up of ships that can launch projectiles, and each has associated life points and a damage amount per shot. At the beginning, the teams are located at opposite ends of the map, as are the flags of each team.

> ## Entities involved

 - `Commanders`
 - `Subordinates`
 - `Obstacles`
 - `Projectiles`
 - `Flags`

> ## Defined relationships

 - `Commander-Subordinate`: The commander gives a set of instructions to their subordinates, who inform their commander what they perceive while executing the received instructions.
 - `Ships(commander/subordinate)-Projectile`: Each team member can fire once every certain time, each projectile is instantiated by some ship, and if a ship is hit by a projectile, it decreases its life points.
 - `Ships(commander/subordinate)-Flag`: Each ship can capture the enemy flag.
 - `Obstacle-Projectile`: If a projectile hits an obstacle, it is destroyed.
 - `Ships(commander/subordinate)-Obstacle`: No ship can pass through a point where an obstacle is located.
 - `Ship-Ship`: Ships can destroy each other.

> ## Involved processes

 - `Flag search`: At all times, the commander listens to what their subordinates inform them to find the flag or destroy the enemy commander.
 - `Instruction execution`: At all times, subordinates perform independent actions such as defending or attacking until they are assigned a set of instructions to execute.

## Details

Teams always start at the end corresponding to their flag. Each commander has a determined vision range, as do their subordinates. The environment map is generated by quadrants. Each member of each team has a wait time after each shot. Subordinate ships behave in two distinct ways; they execute the orders received from their commander and, in case they have none, act autonomously according to what is most convenient for them. The commander's ship is capable of seeing everything that its subordinates see.

## Interaction with the system

The way of interacting with the system is through a **special** ship assigned to the user to interact with the simulation. This ship is capable of communicating with the system and asking which is the best course of action to follow to win their team's victory. This query is made in natural language and receives a response on where to go and whether to defend or attack or defend the position. In case it should not move, it will be specified whether it should attack or defend. The response will have the following format:

    Go to the indicated position

    Attack/Defend

### Medium

 - `User controls`: through these, the user modifies the environment in which the simulation takes place.
 - `Screen`: where the user can observe the development of the simulation.

## Variables of interest

From the descriptions above, we can recognize the following variables of interest:

 - `$m,n$`: dimensions of the quadrants
 - `$f$`: distribution function used to generate obstacles
 - `$r$`: vision range of the ships
 - `$t$`: time between each shot by ship
 - `$R$`: range of projectiles
 - `$L_i$`: life points per ship
 - `$D_i$`: damage amount per shot that each ship inflicts
 - `The possibility or not of friendly fire`
 - `The possibility or not of collision between ships`

## Objective

To evaluate the behavior and performance of the commanders when giving instructions to their subordinates, observing the effectiveness and correctness of the given instructions, while also judging the independent actions of the subordinates based on how they impact the final outcome of the confrontation. Attention will also be paid to how the group reacts based on the actions taken by the user.

<center><h1><font size="20px">Implementation Details</font></h1></center>

## Technologies used

> ## Godot 3.5

It is an open-source and free game development engine that allows for the development of 2D and 3D games. Launched in 2014, it has become widely known for its emphasis on ease of use, flexibility, and efficiency, making it accessible to both beginners and experienced developers. The Godot engine offers a wide range of features, including:

 - `Scene Editor`: Allows developers to build games visually, dragging and dropping objects in a 2D or 3D space.
 - `Node System`: Uses a node system to organize code and resources, facilitating reuse and modularity.
 - `Scripting`: Supports GDScript, a proprietary scripting language similar to Python, as well as C# and C++.
 - `Rendering`: Offers support for 2D and 3D rendering, including support for VR/AR.
 - `Physics Engine`: Includes an integrated physics engine that supports both 2D and 3D physics.
 - `Support for Multiple Platforms`: Allows games to be exported to a wide range of platforms, including Windows, macOS, Linux, iOS, Android, and more.

> ## Python

It is a high-level, interpreted, and general-purpose programming language created in 1991. It is very well-known for its clear and readable syntax, making it easy to learn and use, especially for beginners. Additionally, it is a very versatile language used in a wide range of applications, from web development to data science, artificial intelligence, machine learning, automation, and more. Python is a dynamic programming language, meaning that data types are determined at runtime. This allows programmers to write more flexible and less error-prone code. Python is also a statically typed programming language, meaning that the data types of variables must be explicitly declared. One of the most notable features of Python is its extensive support for libraries and frameworks, facilitating the implementation of a wide range of functionalities. Some of the most popular libraries include NumPy and Pandas for data science, Django and Flask for web development, and TensorFlow and PyTorch for machine learning and artificial intelligence.

> ## Mistral 7B Instruct v0.1 Large Language Model (LLM)

It is a generative language model that uses a variety of datasets of public conversations. More information can be found <a href="https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.1">here</a>.

## Simulation Architecture

The simulation is divided into 3 main components; a central **(Simulator)** component, which includes everything related to the simulation, including the medium of communication with it, and two auxiliary components, one responsible for solving pathfinding problems **(Pathfinder)** and another responsible for natural language interpretation **(Instructor)**. These components are connected through a TCP server for communication between them and the exchange of the necessary data for the computations to be performed.

> ## Simulator

It is where the **simulation** process takes place. It is built using Godot to take advantage of its physics engine, its ease in quickly and organizedly mounting visual scenes, as well as allowing for simple code writing. This set of possibilities makes Godot an excellent option for creating simulations.

> ## Pathfinder

It is responsible for computing the paths to the specified positions in such a way that they are the most optimal according to several predefined criteria. These criteria may be the shortest distance, fewer enemies, more hiding spots, etc. It is written in Python 3 to take advantage of the facilities that this language offers in terms of AI algorithm programming, thanks to the wide range of libraries dedicated to this field that have been written in this language. In this case, we use the **NetworkX** library.

### NetworkX

It is a Python library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks. It was designed to work with networks of any type, including social networks, internet networks, transportation networks, collaboration networks, among others. NetworkX provides a wide range of functionalities for analyzing and visualizing networks, making it a valuable tool for researchers and professionals in fields such as physics, biology, sociology, economics, among others.

NetworkX offers several key features, including:

- Network Creation: Allows the creation of networks from scratch or from existing data. NetworkX supports directed and undirected networks, as well as weighted and unweighted networks.
- Network Manipulation: Provides functions to add or remove nodes and edges, change node and edge attributes, and perform other network manipulation operations.
- Network Analysis: Includes a wide range of algorithms to analyze network properties, such as node degree, network density, centrality, community, among others.
- Network Visualization: Offers tools for graphically visualizing networks, facilitating the understanding of the network's structure and properties.

All these features together make this library an excellent option for solving pathfinding problems.

> ## Instructor

It is responsible for answering the natural language query made by the user. For this, we use **Mistral 7B Instruct v0.1 Large Language Model**. This receives a query with the description of the simulation, the objectives, and the current situation of the user along with the positions of the enemies that the commander of their team knows. The response is a position to which to direct themselves in case they need to do so and whether to attack or defend.

# Details

> ## Simulator

It is in this component where the described situation is simulated, and therefore, where everything related to it was programmed.

### Clarifications about the modeled system

 - `Non-stationary dynamic`: the positions of the entities change over time.
 - `Open`: reacts to user interactions through the assigned ship.
 - `With uncertainty`: it can know a certain amount of information, such as the number of different enemies sighted and the possible location of the enemy flag, but cannot know the exact position of the flag until it is found or the exact number of enemies existing or the area where they are located.

### Characteristics of the simulated environment

 - `Little accessible`: agents do not have complete information about the state of the medium.
 - `Non-episodic`: the behavior of the agents does not depend on a certain number of discrete episodes.
 - `Static`: the state does not change

## Agents
The agents present in the simulation are intelligent agents because they exhibit reactive, proactive, and sociable behavior.

 - `reactive`: They are capable of reacting to changes they detect around them (e.g., if a ship detects an enemy, it begins to shoot at it).
 - `pro-active`: They are capable of taking the initiative to achieve their objectives (e.g., a ship can detect several enemies and decide which one to shoot at; if it has been assigned an objective to destroy, it is capable of selecting its own path to pursue it).
 - `sociable`: They exchange information with other agents (each ship communicates to the commander what it sees and what it decides to do, allowing cooperation among them).

### Agent Architecture

The architecture we use for the agents is the Brooks architecture.

In this architecture, decision-making is carried out through a set of behaviors to achieve objectives (Rules of the form situation -> action).
The rules can be triggered simultaneously, so there must be a mechanism to choose between them.
This architecture has a decision-making function that fulfills the following:

A behavior is a pair <c,a> where c is a subset of P and a belongs to Ac.
A behavior is triggered if the environment is in state e.
The set of all behaviors is defined as: beh = {<c,a> | c subset of P ∧ a belongs to Ac}.
Alongside the set R of rules of an agent, R subset of beh, a suppression relation R x R is defined. This relation must fulfill that it is a total strict order.

### Agent Behavior

> ### Commander

The commander employs a search algorithm that, given its range of vision, divides the map into quadrants of the size of its area of vision and for each quadrant chooses a random point that belongs to each quadrant and visits that point. Once a quadrant is visited, it is marked as visited and another is chosen, ensuring that the map is fully visited. The commander receives what its allies see and gives orders accordingly, meaning that when one of the ships or himself detects the enemy flag, he gives the order to gather at that point to capture it.

## Map Generation

Map generation was carried out using a distribution function based on the clock tick to decide if a cell is or is not an obstacle, the function has an offset and a seed that are used to compute the result. For the positioning of the flag, half of the map is chosen to place it, that half is divided into three sections, and from these it is determined which has the least amount of obstacles and in that place the flag is placed in a random point.

> # Searcher

# Experimentation

## Map Generation

In the experimentation with map generation, we observed that passing an offset of 2 or greater was very likely to result in an invalid map, and the opposite using an offset of 0 or 1. We also noticed that given that maps are generated by quadrants whose size we have access to, we appreciate that a smaller size of the quadrants makes it easier to appreciate the patterns of obstacles in the map, not being so when giving a larger size to the quadrants in the map generation. Given the way the flags are placed, we observed that many times the flags are surrounded by obstacles, which we saw as a good idea since it makes it more difficult to access them.

## Agent Search

Given the commander's search algorithm, we observed that the time it takes to find the flag is about 5 minutes, although this time can be shorter given the randomness of the points it chooses, and as we know that it visits the entire map, we can ensure its convergence. Additionally, we know that allied ships, once they see the flag, warn the commander to give the order to gather at that point, which makes the time shorter.

# How to start

In there is an executable on the folder exe , one for each system linux an windows
